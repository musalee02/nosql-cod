"""
Base class per exploit NoSQL Injection - PortSwigger Labs
Contiene metodi comuni riutilizzabili da tutti gli exploit.
"""
import requests
import sys
from lxml import html
import urllib3

# Disabilita i warning SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==================== GESTIONE COLORI ====================
try:
    from colorama import init, Fore, Style
    init(autoreset=True)
    GREEN = Fore.GREEN
    RED = Fore.RED
    CYAN = Fore.CYAN
    YELLOW = Fore.YELLOW
    WHITE = Fore.WHITE
    RESET = Style.RESET_ALL
    BOLD = Style.BRIGHT
except Exception:
    class Fore: RED = ''; GREEN = ''; YELLOW = ''; BLUE = ''; CYAN = ''; WHITE = ''
    class Style: RESET_ALL = ''; BRIGHT = ''
    GREEN = ''; RED = ''; CYAN = ''; YELLOW = ''; WHITE = ''; RESET = ''; BOLD = ''

def print_error(msg): print(f"{RED}[-] {msg}{RESET}")
def print_success(msg): print(f"{GREEN}[+] {msg}{RESET}")
def print_info(msg): print(f"{CYAN}[*] {msg}{RESET}")

# ==================== COSTANTI COMUNI ====================
HTTP_TIMEOUT = 10
LOGIN_ENDPOINT = "/login"
FORGOT_PASSWORD_ENDPOINT = "/forgot-password"
MY_ACCOUNT_ENDPOINT = "/my-account"
SOLVED_XPATH = '//*[@id="notification-labsolved"]/div/h4'


class BaseNoSQLExploit:
    """Classe base per exploit NoSQL injection."""
    
    def __init__(self, lab_id):
        """
        Inizializza l'exploit con il LAB_ID di PortSwigger.
        
        Args:
            lab_id: Codice identificativo del lab
        """
        self.lab_id = lab_id
        self.base_url = f"https://{lab_id}.web-security-academy.net"
        self.login_url = f"{self.base_url}{LOGIN_ENDPOINT}"
        
        # Configura sessione HTTP
        self.session = requests.Session()
        self.session.headers.update({"User-Agent": "Mozilla/5.0 (NoSQLi-Solver)"})
        self.session.verify = False
    
    def check_lab_status(self):
        """
        Verifica che il lab sia raggiungibile.
        
        Returns:
            bool: True se il lab è raggiungibile, False altrimenti
        """
        try:
            response = self.session.get(self.base_url, timeout=HTTP_TIMEOUT)
            if response.status_code == 200:
                print_success(f"Lab raggiungibile: {self.base_url}")
                return True
            else:
                print_error(f"Lab non raggiungibile (Status: {response.status_code})")
                return False
        except Exception as e:
            print_error(f"Errore connessione: {e}")
            return False
    
    def get_csrf_token(self, url):
        """
        Estrae il token CSRF da una pagina HTML.
        
        Args:
            url: URL della pagina da cui estrarre il token
            
        Returns:
            str: Token CSRF, stringa vuota se non trovato
        """
        try:
            response = self.session.get(url, timeout=HTTP_TIMEOUT)
            tree = html.fromstring(response.text)
            tokens = tree.xpath('//input[@name="csrf"]/@value')
            return tokens[0] if tokens else ""
        except Exception as e:
            print_error(f"Errore estrazione CSRF token: {e}")
            return ""
    
    def check_if_solved(self, response):
        """
        Verifica se il lab è stato risolto controllando l'elemento 'notification-labsolved'.
        
        Args:
            response: Oggetto Response di requests
            
        Returns:
            bool: True se il lab è risolto, False altrimenti
        """
        try:
            tree = html.fromstring(response.content)
            return bool(tree.xpath(SOLVED_XPATH))
        except Exception:
            return False
    
    def verify_solution(self):
        """
        Verifica se il lab è stato risolto controllando la homepage.
        
        Returns:
            bool: True se risolto, False altrimenti
        """
        print_info("\nVerifica soluzione del lab...")
        
        try:
            response = self.session.get(self.base_url)
            
            if self.check_if_solved(response):
                print_success("\n" + "="*60)
                print_success("LAB RISOLTO CON SUCCESSO!")
                print_success("="*60)
                return True
            else:
                print_error("Lab non ancora risolto")
                return False
                
        except Exception as e:
            print_error(f"Errore verifica: {e}")
            return False
    
    def send_json_login(self, username, password, extra_data=None):
        """
        Invia una richiesta di login in formato JSON.
        Utile per exploit NoSQL injection.
        
        Args:
            username: Username (può essere un dizionario per injection)
            password: Password (può essere un dizionario per injection)
            extra_data: Dati aggiuntivi da includere nel payload (es. $where)
            
        Returns:
            Response: Oggetto Response di requests
        """
        headers = {"Content-Type": "application/json"}
        data = {
            "username": username,
            "password": password
        }
        
        # Aggiungi dati extra se forniti (es. $where per injection avanzate)
        if extra_data:
            data.update(extra_data)
        
        try:
            response = self.session.post(
                self.login_url,
                json=data,
                headers=headers,
                allow_redirects=True,
                timeout=HTTP_TIMEOUT
            )
            return response
        except Exception as e:
            print_error(f"Errore durante invio JSON login: {e}")
            return None
    
    def standard_login(self, username, password):
        """
        Effettua un login standard con form e CSRF token.
        
        Args:
            username: Username
            password: Password
            
        Returns:
            bool: True se login riuscito, False altrimenti
        """
        print_info(f"\nLogin con {username}:{password}")
        
        # Ottieni token CSRF
        csrf_token = self.get_csrf_token(self.login_url)
        
        login_data = {
            "csrf": csrf_token,
            "username": username,
            "password": password
        }
        
        try:
            response = self.session.post(
                self.login_url,
                data=login_data,
                allow_redirects=True,
                timeout=HTTP_TIMEOUT
            )
            
            if response.status_code == 200 and "Your username is:" in response.text:
                print_success("Login effettuato con successo!")
                return True
            else:
                print_error("Login fallito")
                return False
                
        except Exception as e:
            print_error(f"Errore durante login: {e}")
            return False
    
    @staticmethod
    def validate_lab_id(lab_id, placeholder="INSERT_YOUR_LAB_ID_HERE"):
        """
        Valida che il LAB_ID sia stato configurato correttamente.
        
        Args:
            lab_id: LAB_ID da validare
            placeholder: Placeholder da controllare
            
        Returns:
            bool: True se valido, False altrimenti
        """
        if lab_id == placeholder or "INSERT" in lab_id or "YOUR" in lab_id:
            print_error("\nERRORE: Devi impostare il LAB_ID nello script!")
            print_info("Esempio: LAB_ID = '0a12003404bd3fe180f562b700ab0012'")
            return False
        return True
    
    def run(self):
        """
        Metodo principale da sovrascrivere nelle classi figlie.
        Contiene la logica specifica dell'exploit.
        """
        raise NotImplementedError("Implementa il metodo run() nella classe figlia")
